#Generate new language
#' Make Language
#'
#' Copies and mutates the parent's langauge to create a new language for a founder party.
#' @param P A list of parameters.
#' @param phonemeProbab The probability of gaining each phoneme in the population.
#' @param phonemeRelatedness The phoneme relatedness list.
#' @param language The parent langauge to mutate into a new language.
#' @param popSize The number of individuals in the parent poultaion.
#' @keywords Language
#' @export
#'
MakeLanguage <- function(P, phonemeProbab, phonemeRelatedness, language, popSize){
  #get the number of mutations per langauge
  #round fractions based on chance to get a whole number
  #Test whether to add or lose based on number of existing phonemes
  if(P$UsePopSize){
    NumMutations <- P$MutRat*(popSize-P$PopSizeInfo[2]+1)^(-1/3) 
  }else{
    NumMutations <- P$MutRat 
  }
  if(runif(1) < NumMutations%%1){
    NumMutations <- NumMutations%/%1+1
  }else{
    NumMutations <- NumMutations%/%1
  }
  
  #set up gain/loss biases
  Gain <- FALSE
  if(P$Bias){
    if(runif(1)>.5){
      Gain <-TRUE
    }
  }
  
  #Figure out what the mutations are
  #Figure out how to bias one way or the other
  ExistingPhonemes <- which(language == 1)
  if(NumMutations != 0){
    for(i in 1:NumMutations){
      suppressWarnings(NewMut <- GetAMutation(P, ExistingPhonemes,
                                              phonemeProbab, phonemeRelatedness,
                                              gain=Gain))
      if(is.null(NewMut)){
        next()
      }
      ExistingPhonemes <- UpdateExistingPhonemes(ExistingPhonemes,NewMut,1)
      if(ncol(NewMut)==2){
        ExistingPhonemes <- UpdateExistingPhonemes(ExistingPhonemes,NewMut,2)
      }  
    }
    
    NewLanguage <- matrix(0, ncol=P$nPhon, nrow=1)
    NewLanguage[1,ExistingPhonemes] <- 1  
  }else{NewLanguage <- language}
  return(NewLanguage)
}

#' Update Existing Phonemes
#'
#' Change the language to incorporation new mutations.
#' @param ExistingPhonemes The Phonemes currently in the language.
#' @param newMut The new mutation generated by GetAMutation().
#' @param index Whether to enact changes to the langauge based on the first or section member of the mutation structure.
#' @keywords Language
#' @export
#'
UpdateExistingPhonemes<-function(existingPhonemes, newMut, index){
  #print(newMut)
  if(newMut[1, index]==0){
    existingPhonemes <- existingPhonemes[-which(existingPhonemes == newMut[2,1])] 
  }else{
    existingPhonemes <- c(existingPhonemes,newMut[2, index])
  }
  return(existingPhonemes)
}

#' Get A Mutation
#'
#' Returns a new Add, Loss, Split, Join, or Shift mutation.  Biases the mutations towards gaining or losing syllables when the parameter Bias==TRUE.
#' @param P A list of parameters.
#' @param phonemes The phonemes currently in the language.
#' @param phonemeProbab The probability of gaining each phoneme in the population.
#' @param phonemeRelatedness The phoneme relatedness list.
#' @param gain Whether to bias the mutations towards gaining syllables (TRUE) or losing them (FALSE).
#' @keywords Language
#' @export
#'
GetAMutation <- function(P, phonemes, phonemeProbab, phonemeRelatedness, gain){
  #Add-1
  #Lose-2
  #Split-3
  #Join-4
  #Shift-5
  if(P$Bias){
    if(gain){
      type <- sample(1:5,1,prob=P$MutTChan+c(1,0,1,0,0))      
    }else{
      type <- sample(1:5,1,prob=P$MutTChan+c(0,1,0,1,0))
    }
  }else{
    type <- sample(1:5,1,prob=P$MutTChan) 
  }
  
  if(length(phonemes) == P$MinVow+P$MinCon){
    if(type %in% c(2,4)){return(NULL)}#too few phonemes, cannot lose any
  }
  if(length(phonemes) == P$AvePho[3]){
    if(type %in% c(1,3,5)){return(NULL)}#too many phonemes, cannot add more or shift
  }
  
  if(type==1){#Add
    if(length((1:P$nPhon)[-phonemes]) == 1){return((1:P$nPhon)[-phonemes])
    }else{return(rbind(1,sample((1:P$nPhon)[-phonemes],1, prob=phonemeProbab[-phonemes])))}
  }
  
  if(type==2){#Loss
    #figure out what is available for loss
    if(length(phonemes[which(phonemes<=P$nConse)]) == P$MinCon){
      Ind <- which(phonemes > P$nConse)
    }else if(length(phonemes[which(phonemes>P$nConse)]) == P$MinVow){
      Ind <- which(phonemes <= P$nConse)
    }else{Ind <- 1:length(phonemes)}
    
    if(length(phonemes[Ind]) == 1){return(phonemes[Ind])
    }else{return(rbind(0,sample(phonemes[Ind],1,prob=1-phonemeProbab[phonemes[Ind]])))}
  }
  
  if(type==3){#Split
    Split <- GetASplitShiftJoinMut(phonemes, phonemeRelatedness, NULL, "Split")
    if(length(Split)!=0){
      return(rbind(1,Split)) 
    }else{return(NULL)}
  }
  
  if(type==4){#Join
    #figure out what is available for loss
    if(length(phonemes[which(phonemes<=P$nConse)]) == P$MinCon){
      Ind <- which(phonemes > P$nConse)
    }else if(length(phonemes[which(phonemes>P$nConse)]) == P$MinVow){
      Ind <- which(phonemes <= P$nConse)
    }else{Ind <- 1:length(phonemes)}
    Join <- GetASplitShiftJoinMut(phonemes[Ind], phonemeRelatedness, NULL, "Join")
    if(length(Join)!=0){
      return(rbind(0,Join)) 
    }else{return(NULL)}
  }
  
  if(type==5){#shift
    Shift <- GetASplitShiftJoinMut(phonemes, phonemeRelatedness, NULL, "Shift")
    if(length(Shift)!=0){
      return(rbind(c(0,1),Shift)) 
    }else{return(NULL)}
  }
}

#' Get A Split Shift Join Mutation
#'
#' Recursively calls itself until a phoneme is found that can be used the generate the mutation type of interest.  Returns Null if no phoneme can mutate appropriately.
#' @param phonemes Phonemes that can be mutated.
#' @param phonemeRelatedness The phoneme relatedness list.
#' @param unusable Phonemes that cannot be used to obtain the correct type of mutation.
#' @param type Which kind of mutation to create: Split, Join, or Shift.
#' @keywords Language
#' @export
#'
GetASplitShiftJoinMut <- function(phonemes, phonemeRelatedness, unusable=NULL, type){
  
  if(length(unusable)+1 == length(phonemes)){#no phonemes remain
    warning(paste0("Failed to return mutation of type ", type, "."))
    return(NULL)
  }
  
  if(length(unusable)!=0){#subsequent runs
    MutPho <- sample(phonemes[-which(phonemes %in% unusable)],1) 
  }else{#first run
    MutPho <- sample(phonemes,1)
  }
  Potential <- phonemeRelatedness[[MutPho]]
  
  #get the list of choice #remain draw as choice
  if(type == "Join"){
    Drawn <- which((Potential[,1] %in% c(phonemes)))
  }else{#split or Shift
    Drawn <- which(!(Potential[,1] %in% c(phonemes))) 
  }
  
  
  
  if(length(Drawn) != 0){#at least one choice
    if(length(Drawn) > 1){#multiple choices
      if(type =="Shift"){
        return(c(MutPho, sample(Potential[Drawn,1],1,prob=Potential[Drawn,2])))
      }else{#Split or Join
        return(sample(Potential[Drawn,1],1,prob=Potential[Drawn,2]))
      }
      
      
      #only one choice
    }else if(type=="Shift"){
      return(c(MutPho,Potential[Drawn,1]))
    }else{return(Potential[Drawn,1])}#Split or Join
    
    
  }else{#Did not pull a good index, try again
    return(GetASplitShiftJoinMut(phonemes, phonemeRelatedness, c(unusable,MutPho), type))
  }
}